---
import Page from "../../../layouts/Page.astro";
---

<Page title="Photo Pin Tool">
	<div class="ui">
		<div id="edit" class="flex">
			<div class="stack">
				<label for="pinColor">Body</label>
				<input id="pinColor" type="color" value="#7711BB" />
			</div>

			<div class="stack">
				<label for="sides">Side</label>
				<select name="sides" id="sides">
					<option value="bottom">Bottom</option>
					<option value="left">Left</option>
					<option value="top">Top</option>
					<option value="right">Right</option>
				</select>
			</div>

			<div class="stack">
				<label for="icons">Icon</label>
				<select name="icons" id="icons">
					<optgroup label="Outline">
						<option
							value="/assets/pins/outlined/dot.svg"
							label="Dot"></option>
						<option
							value="/assets/pins/outlined/heart.svg"
							label="Heart"></option>
						<option
							value="/assets/pins/outlined/home.svg"
							label="Home"></option>
						<option
							value="/assets/pins/outlined/road.svg"
							label="Road"></option>
						<option
							value="/assets/pins/outlined/star.svg"
							label="Star"></option>
					</optgroup>
					<optgroup label="Filled">
						<option value="/assets/pins/filled/dot.svg" label="Dot"
						></option>
						<option
							value="/assets/pins/filled/heart.svg"
							label="Heart"></option>
						<option
							value="/assets/pins/filled/home.svg"
							label="Home"></option>
						<option
							value="/assets/pins/filled/road.svg"
							label="Road"></option>
						<option
							value="/assets/pins/filled/star.svg"
							label="Star"></option>
					</optgroup>
				</select>
			</div>
			<div class="stack">
				<label for="txtColor">Color</label>
				<input id="txtColor" type="color" value="#FFFFFF" />
			</div>
			<div class="stack">
				<label for="pinText">Text</label>
				<input id="pinText" type="text" value="Pin Text" />
			</div>
			<div class="stack">
				<label for="sizes">Size</label>
				<select name="sizes" id="sizes">
					<option value="1" label="S"></option>
					<option value="1.36" label="M"></option>
					<option value="1.69" label="L"></option>
					<option value="2" label="XL"></option>
				</select>
			</div>
		</div>
		<div class="btns">
			<div class="flex">
				<button id="undo">Undo</button>
				<button id="redo">Redo</button>
			</div>
			<div class="flex">
				<button id="zoomOut">-</button>
				<button id="zoomReset">Reset Zoom</button>
				<button id="zoomIn">+</button>
			</div>
			<div class="flex">
				<button id="save" disabled>Save</button>
				<button id="saveQ">?</button>
			</div>
		</div>
		<canvas id="pcanvas" width="600" height="100"></canvas>
		<canvas id="canvas" width="600" height="300"></canvas>
	</div>
	<dialog id="hi">
		<h1>Welcome ðŸ‘‹</h1>
		<ol>
			<li><strong>Drag</strong> to place pins.</li>
			<li><strong>Click</strong> to customize.</li>
			<li><strong>Save</strong> when you're done.</li>
		</ol>
		<p>Let's get started by picking an image!</p>
		<form method="dialog">
			<input id="pick" type="file" accept="image/*" />
			<button id="btnStart" disabled>Ready</button>
		</form>
	</dialog>
	<dialog id="help">
		<h1>Tips and Tricks</h1>
		<ol>
			<li><strong>Right-Click</strong> your image</li>
			<li><strong>Choose</strong> "Save Image As"</li>
		</ol>
		<form method="dialog">
			<button id="btnStart">Got it</button>
		</form>
	</dialog>
	<style>
		dialog {
			font-size: x-large;
			line-height: 1.75em;
			padding: 2rem;
			max-width: 60ch;
		}

		dialog[open]::backdrop {
			backdrop-filter: blur(1rem) brightness(0.9);
		}

		dialog > form {
			display: grid;
			gap: 1rem;
			padding-top: 1rem;
		}

		dialog > ol {
			display: grid;
			gap: 1rem;
			padding-top: 1rem;
			padding-bottom: 1rem;
		}

		#btnStart {
			justify-self: right;
			padding: 0.5rem 1rem;
		}

		#preview {
			padding: 1rem;
		}

		#edit {
			display: none;
			position: absolute;
			z-index: 99;
			background-color: #8882;
			border-radius: 0.25rem;
			padding: 1rem;
			backdrop-filter: blur(1rem);
		}
		#edit.show {
			display: flex;
		}

		#ppin {
			user-select: none;
			cursor: grab;
			padding: 0.5rem;
			background-color: #22aaaa;
			align-items: center;
			border-radius: 0.25rem;
		}

		#ppin img {
			max-width: 1.5rem;
			max-height: 1.5rem;
			z-index: 99;
		}

		.stack {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.flex {
			display: flex;
			gap: 1rem;
		}

		.btns {
			display: flex;
			gap: 1.5rem;
			justify-content: space-between;
		}

		.wrap {
			display: flex;
			/* justify-content: center; */
			gap: 2rem;
		}

		.pin {
			align-items: center;
		}

		.pin svg {
			height: 2rem;
		}

		.ui {
			display: grid;
			gap: 1rem;
			margin: 0 auto;
			padding: 2rem;
		}

		.ui img {
			max-width: 2rem;
			max-height: 2rem;
		}

		#pcanvas {
			border: 1px solid #8882;
		}

		#canvas {
			margin-top: -1rem;
			border: 1px solid #8882;
		}

		#pick {
			cursor: pointer;
		}
	</style>

	<script>
		import PinHist from "./history";
		import Pin, { type PinSide } from "./pin";

		function init() {
			const dialog_hi = document.getElementById(
				"hi",
			) as HTMLDialogElement;
			dialog_hi.addEventListener("close", () => {
				console.log("hi dialog closed");
			});

			const dialog_help = document.getElementById(
				"help",
			) as HTMLDialogElement;
			dialog_help.addEventListener("close", () => {
				console.log("help dialog closed");
			});
			// dialog_help.showModal();

			// "Close" button closes the dialog
			const btnStart = document.getElementById(
				"btnStart",
			) as HTMLButtonElement;
			btnStart.addEventListener("click", () => {
				console.log("start clicked");
				dialog_hi.close();
			});

			console.log("init");
			const pcanvas = document.getElementById(
				"pcanvas",
			) as HTMLCanvasElement;

			if (!pcanvas) {
				console.log("no canvas");
				return;
			}

			const pctx = pcanvas.getContext("2d") as CanvasRenderingContext2D;
			const canvas = document.getElementById(
				"canvas",
			) as HTMLCanvasElement;
			const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;

			canvas.addEventListener(
				"click",
				(e) => {
					dialog_hi.showModal();
				},
				{ once: true },
			);

			document.onkeyup = (e) => {
				if (e.ctrlKey && e.key === "s") {
					quicksave();
				}

				if (e.ctrlKey && e.key === "z") {
					undoEdit();
				}

				if (e.ctrlKey && e.key === "y") {
					redoEdit();
				}
			};

			const save = document.getElementById("save") as HTMLButtonElement;
			function quicksave() {
				const link = document.createElement("a");
				link.download = filename;
				link.href = canvas.toDataURL();
				link.click();
			}
			save.onclick = quicksave;
			const saveQ = document.getElementById("saveQ") as HTMLButtonElement;
			saveQ.onclick = () => {
				console.log("saveQ");
				dialog_help.showModal();
				console.log("help dialog opened");
			};

			const undo = document.getElementById("undo") as HTMLButtonElement;
			function undoEdit() {
				const pins = state.history.undo();
				console.log("undo", pins);
				if (!pins) return;
				state.placed = pins;
				draw();
			}
			undo.onclick = undoEdit;

			const redo = document.getElementById("redo") as HTMLButtonElement;
			function redoEdit() {
				const pins = state.history.redo();
				console.log("redo", pins);
				if (!pins) return;
				state.placed = pins;
				draw();
			}
			redo.onclick = redoEdit;

			const zoomIn = document.getElementById(
				"zoomIn",
			) as HTMLButtonElement;
			zoomIn.onclick = () => {
				state.zoom *= 1.01;
				draw();
			};
			const zoomReset = document.getElementById(
				"zoomReset",
			) as HTMLButtonElement;
			zoomReset.onclick = () => {
				state.zoom = 1;
				draw();
			};
			const zoomOut = document.getElementById(
				"zoomOut",
			) as HTMLButtonElement;
			zoomOut.onclick = () => {
				state.zoom *= 0.99;
				draw();
			};

			const pick = document.getElementById("pick") as HTMLInputElement;
			const photo = new Image();
			let ppin = new Pin(
				pctx,
				{ top: 40, left: 60, width: 100, height: 30 },
				"Pin Text",
				"#7711BB",
				"white",
				"/assets/pins/outlined/dot.svg",
			);

			function drawPreview() {
				pctx.clearRect(0, 0, pctx.canvas.width, pctx.canvas.height);
				ppin.drawPin();
				// Sconsole.log("preview drawn");
			}

			const img = new Image();
			img.src = "/assets/pins/outlined/dot.svg";
			img.onload = () => {
				console.log("icon loaded");
				drawPreview();
			};

			const sides = document.getElementById("sides") as HTMLSelectElement;

			const icons = document.getElementById("icons") as HTMLSelectElement;
			const pinColor = document.getElementById(
				"pinColor",
			) as HTMLInputElement;
			const txtColor = document.getElementById(
				"txtColor",
			) as HTMLInputElement;
			const pinText = document.getElementById(
				"pinText",
			) as HTMLInputElement;

			const state = {
				placed: [] as Pin[],
				held: null as Pin | null,
				edit_pin: null as Pin | null,
				canvasHover: false,
				pcanvasHover: false,
				pin_offset_x: 0,
				pin_offset_y: 0,
				dirty: false,
				zoom: 1,
				history: new PinHist(),
			};

			canvas.addEventListener("mouseenter", (e) => {
				// console.log("entered");
				state.canvasHover = true;
				if (state.held) {
					ppin.move(60, 40);
					state.held = state.held.twin(ctx);
					drawPreview();
				}
			});

			pcanvas.addEventListener("mouseenter", (e) => {
				// console.log("entered");
				state.pcanvasHover = true;
			});

			canvas.addEventListener("mouseleave", (e) => {
				state.canvasHover = false;
				if (state.held) {
					//place_pin();
					console.log("left canvas");
					state.held = null;
					draw();
				}
			});

			pcanvas.addEventListener("mouseleave", (e) => {
				state.pcanvasHover = false;
			});

			document.addEventListener("mousemove", (e) => {
				if (!state.held) {
					return;
				}

				if (state.canvasHover) {
					const cbr = canvas.getBoundingClientRect();
					const px = e.clientX - cbr.left;
					const py = e.clientY - cbr.top;
					state.held.move(px, py);
					draw();
				}

				if (state.pcanvasHover) {
					const pcbr = pcanvas.getBoundingClientRect();
					const px = e.clientX - pcbr.left;
					const py = e.clientY - pcbr.top;
					state.held.move(px, py);
					drawPreview();
				}
			});

			canvas.addEventListener("mousedown", (e) => {
				if (!state.canvasHover) return;
				const cbr = canvas.getBoundingClientRect();
				const px = e.clientX - cbr.left;
				const py = e.clientY - cbr.top;
				for (let i = 0; i < state.placed.length; i++) {
					const pin = state.placed[i] as Pin;
					if (pin.isMouseOver(px, py)) {
						canvas.style.cursor = "grabbing";
						state.held = pin;
						state.placed.splice(i, 1);
						hideEdit();
						return;
					}
				}
			});

			pcanvas.addEventListener("mousedown", (e) => {
				const pcbr = pcanvas.getBoundingClientRect();
				const px = e.clientX - pcbr.left;
				const py = e.clientY - pcbr.top;
				// console.log(ppin);
				if (ppin.isMouseOver(px, py)) {
					pcanvas.style.cursor = "grabbing";
					state.held = ppin;
					hideEdit();
				}
			});

			function place_pin() {
				console.log("placing pin");
				if (!state.held) return;
				const cbr = pcanvas.getBoundingClientRect();
				const cx = state.held.x;
				const cy = state.held.y + cbr.top;
				showEdit(cx, cy);
				const pc = state.held.clone();
				state.placed.push(pc);
				state.history.update(state.placed);
				setEdit(pc);
				state.held = null;
				draw();
				console.log("pin placed");
			}

			function setEdit(pin: Pin) {
				state.edit_pin = pin;
				sides.value = pin.side;

				// console.log(pin.icon.src);
				const idx = pin.icon.src.indexOf("/assets");

				if (idx < 0) {
					console.log("no assets");
					return;
				}

				const _src = pin.icon.src.slice(idx);
				icons.value = _src;

				pinColor.value = pin.bg;
				txtColor.value = pin.color;
				pinText.value = pin.text;
			}

			function showEdit(x: number, y: number) {
				const edit = document.getElementById("edit") as HTMLElement;
				edit.style.top = y + "px";
				edit.style.left = x + "px";
				edit.classList.add("show");
			}

			function hideEdit() {
				const edit = document.getElementById("edit") as HTMLElement;
				if (!edit.classList.contains("show")) return;
				edit.classList.remove("show");
				state.edit_pin = null;
			}

			document.addEventListener("mouseup", (e) => {
				canvas.style.cursor = "grab";
				pcanvas.style.cursor = "grab";

				if (!state.held) {
					// if (state.edit_pin) {
					// 	hideEdit();
					// }
					//
					return;
				}

				if (state.canvasHover) {
					place_pin();
				} else if (state.pcanvasHover) {
					state.held = null;
					ppin.move(60, 40); // reset preview pin
					const pcbr = pcanvas.getBoundingClientRect();
					const px = ppin.x + pcbr.left;
					const py = ppin.y + pcbr.top;
					state.edit_pin = ppin;
					showEdit(px, py);
					drawPreview();
				}

				state.pin_offset_x = 0;
				state.pin_offset_y = 0;
			});

			sides.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const sel = e.target as HTMLSelectElement;
				state.edit_pin.side = sel.value as PinSide;
				state.history.update(state.placed);
				drawPreview();
				draw();
				console.log("side changed");
			});

			icons.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const sel = e.target as HTMLSelectElement;
				// img.src = sel.value;
				console.log(sel.value);
				state.edit_pin.updateIcon(sel.value);
				state.history.update(state.placed);
				drawPreview();
				draw();
				console.log("icon changed");
			});

			pinColor.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const cInput = e.target as HTMLInputElement;
				state.edit_pin.bg = cInput.value;
				state.history.update(state.placed);
				drawPreview();
				draw();
				console.log("color changed");
			});

			txtColor.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const cInput = e.target as HTMLInputElement;
				state.edit_pin.color = cInput.value;
				state.history.update(state.placed);
				drawPreview();
				draw();
				console.log("text color changed");
			});

			pinText.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const tInput = e.target as HTMLInputElement;
				state.edit_pin.updateText(tInput.value);
				drawPreview();
				draw();
				console.log("text changed");
			});

			const sizes = document.getElementById("sizes") as HTMLSelectElement;
			sizes.addEventListener("change", (e) => {
				if (!state.edit_pin) {
					console.log("no pin");
					return;
				}
				const sel = e.target as HTMLSelectElement;
				Pin.scale = parseFloat(sel.value);

				state.history.update(state.placed);
				drawPreview();
				draw();
				console.log("size changed");
			});

			let filename = "";

			pick.addEventListener("change", (e) => {
				const picker = e.target as HTMLInputElement;

				if (!picker.files || picker.files.length < 1) {
					alert("No image files selected.");
					return;
				}

				if (picker.files.length > 1) {
					alert("One image file at a time.");
					return;
				}
				const file = picker.files[0];
				const url = URL.createObjectURL(file);
				photo.src = url;
				photo.onload = () => {
					filename = file.name.slice(0, -3) + "jpg";
					save.disabled = false;
					state.dirty = true;
					resize(photo);
					drawPreview();
					draw();
					btnStart.disabled = false;
				};
			});

			function resize(photo: HTMLImageElement) {
				const { width, height } = photo;
				let k = 1;
				if (width < 600) {
					k = 600 / width;
				}

				ctx.canvas.width = k * width;
				ctx.canvas.height = k * height;
				pctx.canvas.width = k * width;
				pcanvas.style.width = k * width + "px";
				canvas.style.width = k * width + "px";
				canvas.style.height = k * height + "px";
			}

			function draw() {
				// wipe canvas
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				// draw user image
				if (photo.src) {
					ctx.drawImage(
						photo,
						0,
						0,
						ctx.canvas.width,
						ctx.canvas.height,
					);
				}

				// console.log(state.placed);

				// draw placed pins
				for (let i = 0; i < state.placed.length; i++) {
					const pin = state.placed[i];
					pin.drawPin();
				}
				// draw held pin
				if (state.held) {
					// state.held.move();
					state.held.drawPin();
				}
			}

			console.log("adding event listener");
			window.addEventListener("beforeunload", (e) => {
				e.preventDefault();

				e.returnValue = "Are you sure you want to leave?";
				if (state.dirty) {
					console.log("dirty");
				}
				if (dialog_hi.open) {
					e.preventDefault();
					e.returnValue = "";
					dialog_hi.close();
					console.log("closed hi");
				}
			});
		}

		document.addEventListener("astro:page-load", init);
	</script>
</Page>
